/**
 * Ïî¨ Îß§ÎãàÏ†Ä Î™®Îìà - ÏñëÎ∞ú 3D Scene, Î†åÎçîÎü¨, Î™®Îç∏ Í¥ÄÎ¶¨ Ï†ÑÎã¥ (ÏµúÏ¢Ö ÏàòÏ†ï)
 */
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js';

export class SceneManager extends EventTarget {
    constructor(canvasContainer) {
        super();
        this.canvasContainer = canvasContainer;
        this.scene = null;
        this.renderer = null;
        
        // ÏñëÎ∞ú Î™®Îç∏ Í¥ÄÎ¶¨
        this.dualFootModel = null; // ÏñëÎ∞úÏùÑ Ìè¨Ìï®ÌïòÎäî Í∑∏Î£π
        this.leftFootModel = null;
        this.rightFootModel = null;
        
        // Geometry Ï†ÄÏû•
        this.leftGeometry = null;
        this.rightGeometry = null;
        
        // Ìó¨Ìçº Í∞ùÏ≤¥Îì§
        this.gridHelper = null;
        this.boxHelper = null;
        this.animationId = null;
        
        // ÌòÑÏû¨ Î∑∞ ÏÉÅÌÉú
        this.currentViewMode = 'mesh';
        this.footVisibility = 'both'; // 'both', 'left', 'right'
    }

    /**
     * Ïî¨ Ï¥àÍ∏∞Ìôî
     */
    init() {
        console.log('üé¨ Scene Manager (ÏñëÎ∞ú ÏßÄÏõê) Ï¥àÍ∏∞Ìôî ÏãúÏûë...');
        
        // Scene ÏÑ§Ï†ï
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0x111827);

        // Î†åÎçîÎü¨ ÏÑ§Ï†ï
        this.renderer = new THREE.WebGLRenderer({ 
            antialias: true, 
            alpha: true, 
            preserveDrawingBuffer: true 
        });
        this.renderer.setPixelRatio(window.devicePixelRatio);
        this.renderer.setSize(this.canvasContainer.clientWidth, this.canvasContainer.clientHeight);
        this.canvasContainer.appendChild(this.renderer.domElement);

        // Ï°∞Î™Ö ÏÑ§Ï†ï
        this.setupLighting();
        
        // Ìó¨Ìçº Í∞ùÏ≤¥ ÏÑ§Ï†ï
        this.setupHelpers();

        console.log('‚úÖ Scene Manager (ÏñëÎ∞ú ÏßÄÏõê) Ï¥àÍ∏∞Ìôî ÏôÑÎ£å');
        return this.renderer.domElement;
    }

    /**
     * Ï°∞Î™Ö ÏÑ§Ï†ï
     */
    setupLighting() {
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        this.scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
        directionalLight.position.set(100, 100, 100);
        this.scene.add(directionalLight);

        // Ï∂îÍ∞Ä Ï°∞Î™Ö (ÏñëÎ∞úÏùÑ Îçî Ïûò Î≥¥Ïù¥Í≤å)
        const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight2.position.set(-100, 100, -100);
        this.scene.add(directionalLight2);
    }

    /**
     * Ìó¨Ìçº Í∞ùÏ≤¥ ÏÑ§Ï†ï
     */
    setupHelpers() {
        // Í∑∏Î¶¨Îìú Ìó¨Ìçº
        this.gridHelper = new THREE.GridHelper(1000, 50, 0x888888, 0x444444);
        this.gridHelper.visible = false;
        this.scene.add(this.gridHelper);

        // Î∞îÏö¥Îî© Î∞ïÏä§ Ìó¨Ìçº
        this.boxHelper = new THREE.Box3Helper(new THREE.Box3(), 0xffff00);
        this.boxHelper.visible = false;
        this.scene.add(this.boxHelper);
    }

    /**
     * ÏñëÎ∞ú geometry ÏÑ§Ï†ï
     */
    setDualGeometry(leftGeometry, rightGeometry) {
        console.log('üë£ ÏñëÎ∞ú geometry ÏÑ§Ï†ï...');
        
        this.leftGeometry = leftGeometry;
        this.rightGeometry = rightGeometry;
        
        // Í∏∞Ï°¥ Î™®Îç∏ Ï†ïÎ¶¨
        this.cleanupCurrentModels();
        
        console.log('‚úÖ ÏñëÎ∞ú geometry ÏÑ§Ï†ï ÏôÑÎ£å');
    }

    /**
     * ÏñëÎ∞ú Î™®Îç∏ Î∑∞ ÏóÖÎç∞Ïù¥Ìä∏
     */
    updateDualModelView(viewType, leftColor = '#3b82f6', rightColor = '#10b981') {
        if (!this.leftGeometry || !this.rightGeometry) {
            console.warn('‚ö†Ô∏è ÏñëÎ∞ú geometryÍ∞Ä ÏÑ§Ï†ïÎêòÏßÄ ÏïäÏùå');
            return;
        }
        
        console.log(`üé® ÏñëÎ∞ú Î™®Îç∏ Î∑∞ ÏóÖÎç∞Ïù¥Ìä∏: ${viewType}`);
        
        this.currentViewMode = viewType;
        this.cleanupCurrentModels();

        this.dualFootModel = new THREE.Group();
        this.dualFootModel.name = 'DualFootModel';

        // 1. ÏôºÎ∞ú, Ïò§Î•∏Î∞ú Î™®Îç∏ ÏÉùÏÑ±
        this.leftFootModel = this.createFootModel(this.leftGeometry, leftColor, viewType, 'left');
        this.leftFootModel.name = 'LeftFoot';
        
        this.rightFootModel = this.createFootModel(this.rightGeometry, rightColor, viewType, 'right');
        this.rightFootModel.name = 'RightFoot';

        // 2. Í∞Å Î∞ú Î™®Îç∏ÏùÑ Î®ºÏ†Ä Ï§ëÏïô Ï†ïÎ†¨
        this.alignSingleFoot(this.leftFootModel);
        this.alignSingleFoot(this.rightFootModel);

        // 3. Ï§ëÏïô Ï†ïÎ†¨Îêú Î™®Îç∏Îì§ÏùÑ Í∏∞Ï§ÄÏúºÎ°ú Ï¢åÏö∞ Î∞∞Ïπò
        this.positionDualFeet();
        
        this.dualFootModel.add(this.leftFootModel);
        this.dualFootModel.add(this.rightFootModel);
        
        this.scene.add(this.dualFootModel);

        // 4. Ï†ÑÏ≤¥ Í∑∏Î£πÏùÑ Ï§ëÏïô Ï†ïÎ†¨ Î∞è Ïä§ÏºÄÏùºÎßÅ
        this.alignAndScaleDualModel();
        
        this.updateHelpers();
        this.applyFootVisibility();

        this.dispatchEvent(new CustomEvent('dualModelUpdated', {
            detail: { 
                viewType, 
                dualModel: this.dualFootModel,
                leftModel: this.leftFootModel,
                rightModel: this.rightFootModel
            }
        }));
        
        console.log('‚úÖ ÏñëÎ∞ú Î™®Îç∏ Î∑∞ ÏóÖÎç∞Ïù¥Ìä∏ ÏôÑÎ£å');
    }

    /**
     * Í∞úÎ≥Ñ Î∞ú Î™®Îç∏ ÏÉùÏÑ± (Matrix ÎØ∏Îü¨ÎßÅ Î∞©Ïãù Ï†ÅÏö©)
     */
    createFootModel(geometry, color, viewType, footType) {
        const baseMaterialProps = {
            color: color,
            vertexColors: geometry.hasAttribute('color'),
            side: THREE.DoubleSide,
        };

        let material;
        switch(viewType) {
            case 'points':
                material = new THREE.PointsMaterial({ ...baseMaterialProps, size: 0.1 });
                break;
            case 'wireframe':
                material = new THREE.MeshBasicMaterial({ ...baseMaterialProps, wireframe: true });
                break;
            case 'mesh':
            default:
                material = new THREE.MeshStandardMaterial({ ...baseMaterialProps, flatShading: true });
                break;
        }

        const mesh = (viewType === 'points') ? 
            new THREE.Points(geometry, material) : 
            new THREE.Mesh(geometry, material);
            
        const footModel = new THREE.Group();
        footModel.add(mesh);
        footModel.userData.footType = footType;

        // (ÌïµÏã¨ ÏàòÏ†ï) Ïò§Î•∏Î∞úÏùº Í≤ΩÏö∞, MatrixÎ•º Ïù¥Ïö©Ìï¥ ÎØ∏Îü¨ÎßÅ
        if (footType === 'right') {
            const mirrorMatrix = new THREE.Matrix4().makeScale(-1, 1, 1);
            footModel.applyMatrix4(mirrorMatrix);
        }
        
        return footModel;
    }

    /**
     * ÏñëÎ∞ú Î∞∞Ïπò (Í∞ÑÍ≤© ÏàòÏ†ï)
     */
    positionDualFeet() {
        if (!this.leftFootModel || !this.rightFootModel) return;

        const leftBox = new THREE.Box3().setFromObject(this.leftFootModel);
        const leftSize = leftBox.getSize(new THREE.Vector3());
        
        const spacing = leftSize.x * 0.6;
        
        const leftPosition = -(leftSize.x / 2) - (spacing / 2);
        const rightPosition = (leftSize.x / 2) + (spacing / 2);
        
        this.leftFootModel.position.x = leftPosition;
        this.rightFootModel.position.x = rightPosition;
        
        console.log(`üìê ÏñëÎ∞ú Î∞∞Ïπò ÏôÑÎ£å: ÏôºÎ∞ú(${leftPosition.toFixed(1)}), Ïò§Î•∏Î∞ú(${rightPosition.toFixed(1)}), Í∞ÑÍ≤©(${spacing.toFixed(1)})`);
    }

    /**
     * ÏñëÎ∞ú Î™®Îç∏ Ï†ïÎ†¨ Î∞è Ïä§ÏºÄÏùºÎßÅ
     */
    alignAndScaleDualModel() {
        if (!this.dualFootModel) return;

        const dualBox = new THREE.Box3().setFromObject(this.dualFootModel);
        const dualCenter = dualBox.getCenter(new THREE.Vector3());
        this.dualFootModel.position.sub(dualCenter);
        
        const dualSize = dualBox.getSize(new THREE.Vector3());
        const maxDim = Math.max(dualSize.x, dualSize.y, dualSize.z);
        const desiredSize = 180;
        const scale = desiredSize / maxDim;
        
        this.dualFootModel.scale.set(scale, scale, scale);
        
        console.log(`üìè ÏñëÎ∞ú Ïä§ÏºÄÏùºÎßÅ ÏôÑÎ£å: ${scale.toFixed(3)}Î∞∞`);
    }

    /**
     * Í∞úÎ≥Ñ Î∞ú Ï†ïÎ†¨
     */
    alignSingleFoot(footModel) {
        if (!footModel || footModel.children.length === 0) return;

        const mesh = footModel.children[0];
        
        const initialBox = new THREE.Box3().setFromObject(mesh);
        const initialSize = initialBox.getSize(new THREE.Vector3());

        if (initialSize.y > initialSize.x && initialSize.y > initialSize.z) {
            footModel.rotation.x = -Math.PI / 2;
        } else if (initialSize.x > initialSize.y && initialSize.x > initialSize.z) {
            footModel.rotation.z = -Math.PI / 2;
        }

        const rotatedBox = new THREE.Box3().setFromObject(footModel);
        const center = rotatedBox.getCenter(new THREE.Vector3());
        footModel.position.sub(center);
    }

    /**
     * Î∞ú Í∞ÄÏãúÏÑ± ÏÑ§Ï†ï
     */
    setFootVisibility(visibilityMode) {
        this.footVisibility = visibilityMode;
        this.applyFootVisibility();
        
        console.log(`üëÅÔ∏è Î∞ú Í∞ÄÏãúÏÑ± Î≥ÄÍ≤Ω: ${visibilityMode}`);
    }

    /**
     * Î∞ú Í∞ÄÏãúÏÑ± Ï†ÅÏö©
     */
    applyFootVisibility() {
        if (!this.leftFootModel || !this.rightFootModel) return;

        switch(this.footVisibility) {
            case 'left':
                this.leftFootModel.visible = true;
                this.rightFootModel.visible = false;
                break;
            case 'right':
                this.leftFootModel.visible = false;
                this.rightFootModel.visible = true;
                break;
            case 'both':
            default:
                this.leftFootModel.visible = true;
                this.rightFootModel.visible = true;
                break;
        }
    }

    /**
     * Í∏∞Ï°¥ Î™®Îç∏Îì§ Ï†ïÎ¶¨
     */
    cleanupCurrentModels() {
        if (this.dualFootModel) {
            this.scene.remove(this.dualFootModel);
            this.dualFootModel.traverse(child => {
                if (child.isMesh || child.isPoints) {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) child.material.dispose();
                }
            });
        }
        
        this.dualFootModel = null;
        this.leftFootModel = null;
        this.rightFootModel = null;
    }

    /**
     * Ìó¨Ìçº ÏóÖÎç∞Ïù¥Ìä∏
     */
    updateHelpers() {
        if (!this.dualFootModel) return;

        const finalBox = new THREE.Box3().setFromObject(this.dualFootModel);
        this.gridHelper.position.y = finalBox.min.y;
        
        this.boxHelper.box.setFromObject(this.dualFootModel);
    }

    /**
     * Í∑∏Î¶¨Îìú ÌÜ†Í∏Ä
     */
    toggleGrid(isVisible) {
        if (this.gridHelper) {
            this.gridHelper.visible = isVisible !== undefined ? isVisible : !this.gridHelper.visible;
        }
        return this.gridHelper ? this.gridHelper.visible : false;
    }
    
    /**
     * ÌôîÎ©¥ Ï∫°Ï≤ò
     */
    captureScreen(camera) {
        if (!this.renderer || !camera) return null;
        
        this.renderer.render(this.scene, camera);
        return this.renderer.domElement.toDataURL('image/png');
    }

    /**
     * Î†åÎçîÎßÅ
     */
    render(camera) {
        if (this.renderer && camera) {
            this.renderer.render(this.scene, camera);
        }
    }

    /**
     * ÏúàÎèÑÏö∞ Î¶¨ÏÇ¨Ïù¥Ï¶à Ï≤òÎ¶¨
     */
    onWindowResize() {
        if (!this.renderer) return;
        
        this.renderer.setSize(this.canvasContainer.clientWidth, this.canvasContainer.clientHeight);
        
        this.dispatchEvent(new CustomEvent('windowResized', {
            detail: {
                width: this.canvasContainer.clientWidth,
                height: this.canvasContainer.clientHeight
            }
        }));
    }

    /**
     * ÌòÑÏû¨ Î™®Îç∏ Î∞òÌôò (ÏñëÎ∞ú Í∑∏Î£π)
     */
    getCurrentModel() {
        return this.dualFootModel;
    }
    
    getLeftFootModel() {
        return this.leftFootModel;
    }

    getRightFootModel() {
        return this.rightFootModel;
    }

    getLeftGeometry() {
        return this.leftGeometry;
    }

    getRightGeometry() {
        return this.rightGeometry;
    }

    getScene() {
        return this.scene;
    }

    getRenderer() {
        return this.renderer;
    }

    /**
     * Ï†ïÎ¶¨ (Î©îÎ™®Î¶¨ Ìï¥Ï†ú)
     */
    dispose() {
        if (this.animationId) {
            cancelAnimationFrame(this.animationId);
        }

        this.cleanupCurrentModels();

        if (this.gridHelper) {
            this.scene.remove(this.gridHelper);
            this.gridHelper.geometry.dispose();
            this.gridHelper.material.dispose();
        }

        if (this.boxHelper) {
            this.scene.remove(this.boxHelper);
            this.boxHelper.geometry.dispose();
            this.boxHelper.material.dispose();
        }

        if (this.renderer) {
            this.renderer.dispose();
            if (this.renderer.domElement.parentNode) {
                this.renderer.domElement.parentNode.removeChild(this.renderer.domElement);
            }
        }

        if (this.scene) {
            this.scene.clear();
        }

        console.log('üßπ Scene Manager (ÏñëÎ∞ú ÏßÄÏõê) Ï†ïÎ¶¨ ÏôÑÎ£å');
    }
}
